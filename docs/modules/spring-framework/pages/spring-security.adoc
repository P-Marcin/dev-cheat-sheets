= Spring Security

image:https://img.shields.io/badge/Documentation-2088E9?logo=quickLook&logoColor[link="https://docs.spring.io/spring-security/reference/index.html",window=_blank]

== Maven Dependencies

[,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-test</artifactId>
    <scope>test</scope>
</dependency>
----

NOTE: Just by adding the dependency, Spring Boot will provide us *sensible defaults*. For example, it will *autoconfigure Basic HTTP Authentication* and secure all REST API endpoints.

CAUTION: Basic HTTP Auth should be used with HTTPS, because username and password are sent over the internet as *base64* encoded and *without HTTPS they can be easily decoded*. It is discouraged to use Basic HTTP Auth in an Enterprise project.

== Basic HTTP Auth

=== Calling REST API endpoint with Basic HTTP Auth

If you'll just send a GET request to `+http://localhost:8080/api/v1/resource+`, you'll get Response Status Code: *401 Unauthorized*.

Basic HTTP Auth requires a header in the request called `Authorization` with value: `Basic dXNlcjphM2JhNmYyOS0xMGU0LTQ5OTctOTg4Mi0yMjM0ODg4M2Q5NTQ=` where after `Basic` there is *base64 encoded username and password*.

.Decoding base64 string
[,shell]
----
$ echo "dXNlcjphM2JhNmYyOS0xMGU0LTQ5OTctOTg4Mi0yMjM0ODg4M2Q5NTQ=" | base64 --decode
user:a3ba6f29-10e4-4997-9882-22348883d954
----

.Encoding base64 string
[,shell]
----
$ echo -n "user:a3ba6f29-10e4-4997-9882-22348883d954" | base64
dXNlcjphM2JhNmYyOS0xMGU0LTQ5OTctOTg4Mi0yMjM0ODg4M2Q5NTQ=
----

=== Customizing username and password

By default, Spring will create a new password *on each deployment*.

You can customize Spring Security username and password with these properties:
[,properties]
----
spring.security.user.name=my-user
spring.security.user.password=my-password
----

=== Using `游릭 RestTemplate` with Basic HTTP Auth

You'll have to invoke https://docs.spring.io/spring-boot/api/java/org/springframework/boot/web/client/RestTemplateBuilder.html#basicAuthentication(java.lang.String,java.lang.String)[`游릭 RestTemplateBuilder#basicAuthentication(String username,
String password)`^] when configuring Bean xref:spring-web-client.adoc#_externalize_base_uri[here].

=== Testing HTTP GET with Basic HTTP Auth

An example how Basic HTTP Auth can be added to the test:

[,java]
----
mockMvc.perform(get("/api/v1/resource")
            .with(httpBasic("my-user", "my-password")) // <1>
            .accept(MediaType.APPLICATION_JSON))
    .andExpect(status().isOk())
    .andExpect(content().contentType(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath("$.content.length()", is(3)));
----
<1> This way we can add `Authorization` header to the request

=== Testing HTTP POST with Basic HTTP Auth

For HTTP POST simply adding to the test:

[,java]
----
.with(httpBasic("my-user", "my-password"))
----

is not enough. You'll get Response Status Code: *403 Forbidden* due to: `Invalid CSRF token found for +http://localhost/api/v1/resource+`.

You can ignore CSRF token only for REST API by creating a `游릭 SecurityConfig`:

[,java]
----
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.authorizeHttpRequests(authorize -> authorize.anyRequest().authenticated()) // <1>
                .httpBasic(Customizer.withDefaults()) // <2>
                .csrf(csrf -> csrf.ignoringRequestMatchers("/api/**")); // <3>
        return httpSecurity.build();
    }

}
----
<1> Require any request to be authenticated
<2> Setup HTTP Basic Auth with the defaults
<3> Do not require CSRF Token on `/api/**` urls

[CAUTION]
====
If your test is annotated with https://docs.spring.io/spring-boot/api/java/org/springframework/boot/test/context/SpringBootTest.html[`@SpringBootTest`^], then you need to create https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html[`游댮 MockMvc`^] like this:

[,java]
----
MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(wac)
    .apply(springSecurity()) // <1>
    .build();
----
<1> Configure `游댮 MockMvc` to use Spring Security

If your test is annotated with https://docs.spring.io/spring-boot/api/java/org/springframework/boot/test/autoconfigure/web/servlet/WebMvcTest.html[`@WebMvcTest`^], then you need to import `游릭 SecurityConfig` by annotating the test class with:

[,java]
----
@Import(SecurityConfig.class)
----
====

== OAuth2 and JWT

=== Overview

OAuth2::
*Authorization Framework* used to grant *limited access* to resources without full access to the account. It allows you *to grant access to a third party application* to *act on your behalf*.

OAuth Roles::
* *Client* - the application requesting access
* *Resource Owner* - the user who wishes to grant an application (Client) access
* *Authorization Server* - verifies the identity of the user then issues access tokens to the application
* *Resource Server* - the resource to access

[]
Client Credentials Flow::
Most common OAuth https://auth0.com/docs/get-started/authentication-and-authorization-flow/which-oauth-2-0-flow-should-i-use[Authorization Flow] for RESTful APIs. It is used by services, where the user is a service role.
+
.Client Credentials Flow with JWT
image::oauth2-client-credentials-flow-with-jwt.png[,600]

JWT::
*JSON Web Token*. It contains *user information* and *authorized roles* (scopes). It has three parts: *Header*, *Payload* (data) and *Signature*. All 3 parts are tokenized using *base64 encoding*.

NOTE: HTTP / REST are *stateless* - each request is *self-contained*. Unlike Web Applications which often use *session id's stored in cookies*.

JWT is *signed* which *prevents clients from altering the contents* of the JWT. It can be signed using a number of techniques:

* *Symmetric encryption* - uses single key to sign, requires key to be shared
* *Asymmetric encryption* - uses Public and Private Keys (known as *Key Pair*)
** *Private Key* is used to generate signature and is not shared
** *Public Key* is shared and is used to verify signature

[]
JWT Verification::
. The Authorization Server *signs JWT* using the *Private Key*
. The Resource Server *requests the Public Key* from the Authorization Server
. Using the *Public Key* the Resource Server *verifies the signature of the JWT*
. The Resource Server can *cache the Public Key* for verification of future requests

IMPORTANT: Once the Resource Server has the Public Key, JWT can be validated *without additional requests* from the Authorization Server.

=== OAuth vs Basic HTTP Auth

* Basic HTTP Auth requires user credentials to be *shared with every resource*
* Basic HTTP Auth sends user credentials *unencrypted* in HTTP header and can be *compromised*
* With OAuth user credentials are *only shared with Authentication Server*
* User credentials *cannot be obtained* from Authorization Token
* Basic HTTP Auth has *no concept of security roles*
* With OAuth2 security roles are *defined in scopes* and *passed in Authorization Token*

IMPORTANT: When we're dealing with security roles, we can *grant access* to resources as needed or *deny access* when appropriate.
